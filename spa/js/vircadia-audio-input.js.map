{"version":3,"file":"vircadia-audio-input.js","mappings":"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","sources":["webpack://@vircadia/web-sdk/./src/domain/audio/AudioConstants.ts","webpack://@vircadia/web-sdk/./src/domain/worklets/AudioInputProcessor.ts"],"sourcesContent":["//\r\n//  AudioConstants.ts\r\n//\r\n//  Created by David Rowe on 11 Sep 2021.\r\n//  Copyright 2021 Vircadia contributors.\r\n//  Copyright 2021 DigiSomni LLC.\r\n//\r\n//  Distributed under the Apache License, Version 2.0.\r\n//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html\r\n//\r\n\r\n/*@devdoc\r\n *  The <code>AudioConstants</code> namespace provides the values of audio constants used in the SDK.\r\n *  <p>C++: <code>AudioConstants</code></p>\r\n *\r\n *  @namespace AudioConstants\r\n *\r\n *  @property {number} SAMPLE_RATE - <code>24000</code> - The audio sample rate, in Hz.\r\n *\r\n *  @property {number} STEREO - <code>2</code> - The number of audio channels for stereo.\r\n *\r\n *  @property {number} NETWORK_FRAME_SAMPLES_STEREO - <code>480</code> - The number of samples in a network packet for a stereo\r\n *      channel.\r\n *  @property {number} NETWORK_FRAME_SAMPLES_PER_CHANNEL - <code>240</code> - The number of samples in a network packet per\r\n *      channel.\r\n *\r\n *  @property {number} NETWORK_FRAME_SECS - <code>0.01</code> - The interval between audio network packets, in seconds.\r\n *  @property {number} NETWORK_FRAME_MSECS - <code>10</code> - The interval between audio network packets, in milliseconds.\r\n *\r\n *  @property {number} AUDIO_WORKLET_BLOCK_SIZE - <code>128</code> - The number of frames in and audio worklet audio block.\r\n */\r\nconst AudioConstants = new class {\r\n    // C++  AudioConstants\r\n\r\n    /* eslint-disable @typescript-eslint/no-magic-numbers */\r\n\r\n    readonly SAMPLE_RATE = 24000;\r\n\r\n    readonly STEREO = 2;\r\n\r\n    readonly NETWORK_FRAME_SAMPLES_STEREO = 480;\r\n    readonly NETWORK_FRAME_SAMPLES_PER_CHANNEL = 240;\r\n\r\n    readonly NETWORK_FRAME_SECS = this.NETWORK_FRAME_SAMPLES_PER_CHANNEL / this.SAMPLE_RATE;\r\n    readonly NETWORK_FRAME_MSECS = this.NETWORK_FRAME_SECS * 1000;\r\n\r\n    readonly AUDIO_WORKLET_BLOCK_SIZE = 128;  // 128 frames of samples.\r\n\r\n}();\r\n\r\nexport { AudioConstants as default };\r\n","//\r\n//  AudioInputProcessor.ts\r\n//\r\n//  Created by David Rowe on 23 Sep 2021.\r\n//  Copyright 2021 Vircadia contributors.\r\n//  Copyright 2021 DigiSomni LLC.\r\n//\r\n//  Distributed under the Apache License, Version 2.0.\r\n//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html\r\n//\r\n\r\nimport AudioConstants from \"../audio/AudioConstants\";\r\n\r\n// see: https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletGlobalScope\r\ndeclare const sampleRate: number;\r\n\r\n/*@devdoc\r\n *  The <code>AudioInputProcessor</code> class implements a Web Audio\r\n *  {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletProcessor|AudioWorkletProcessor} that takes incoming Web\r\n *  Audio and provides it for the SDK to use. It is used as a node in a Web Audio graph in {@link AudioInput}.\r\n *  <p>It runs on its own thread and buffers incoming samples as needed in order to provide the samples to the SDK in the\r\n *  required network frame size.</p>\r\n *  <p>C++: <code>N/A</code></p>\r\n *  @class AudioInputProcessor\r\n *  @param {AudioWorkletNodeOptions} options -\r\n *    {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletProcessor/AudioWorkletProcessor|AudioWorkletProcessor}\r\n *    options.\r\n *\r\n *  @property {MessagePort} port - Used to communicate between the AudioWorkletProcessor object and its internal code. See\r\n *    {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletNode/port|AudioWorkletNode.port}.\r\n */\r\nclass AudioInputProcessor extends AudioWorkletProcessor {\r\n\r\n    // FIXME: All these fields should be private (#s) but Firefox is handling transpiled code with them (Sep 2021).\r\n    readonly FLOAT_TO_INT = 32767;\r\n    readonly LITTLE_ENDIAN = true;\r\n\r\n    _channelCount;\r\n\r\n    _output: Int16Array;\r\n    _outputView: DataView;\r\n    _outputSize: number;\r\n    _outputSampleSize: number;\r\n    _outputIndex = 0;\r\n\r\n    _inputSampleRate: number;\r\n    _inputFraction = 0.0;\r\n    _inputSampleCount = 0;\r\n\r\n    // Downsampling.\r\n    _downsampleRatio = 1.0;\r\n    _inputAccumulator = [0.0, 0.0];\r\n\r\n    // Upsampling.\r\n    _upsampleRatio = 1.0;\r\n    _lastInputValues = [0.0, 0.0];\r\n\r\n    _processor: ((input: Array<Float32Array>) => void);\r\n    _haveReportedUpSampleError = false;\r\n\r\n\r\n    constructor(options?: AudioWorkletNodeOptions) {\r\n        super(options);  // eslint-disable-line\r\n\r\n        this._channelCount = options?.channelCount ? options.channelCount : 1;  // Default to mono.\r\n        this._channelCount = Math.min(this._channelCount, 2);  // Mono or stereo output, only.\r\n        this._inputSampleRate = sampleRate;\r\n\r\n        if (this._inputSampleRate === AudioConstants.SAMPLE_RATE) {\r\n            this._processor = this._convert;\r\n        } else if (this._inputSampleRate > AudioConstants.SAMPLE_RATE) {\r\n            this._processor = this._downsample;\r\n            this._downsampleRatio = AudioConstants.SAMPLE_RATE / this._inputSampleRate;  // < 1.0\r\n            this._inputFraction = 0.0;\r\n        } else {\r\n            this._processor = this._upsample;\r\n            this._upsampleRatio = this._inputSampleRate / AudioConstants.SAMPLE_RATE;  // < 1.0\r\n            this._inputFraction = this._upsampleRatio;\r\n        }\r\n\r\n        this._outputSize = this._channelCount === 1\r\n            ? AudioConstants.NETWORK_FRAME_SAMPLES_PER_CHANNEL\r\n            : AudioConstants.NETWORK_FRAME_SAMPLES_STEREO;\r\n        this._outputSampleSize = this._outputSize / this._channelCount;\r\n        this._output = new Int16Array(this._outputSize);\r\n        this._outputView = new DataView(this._output.buffer);\r\n\r\n        this.port.onmessage = this.onMessage;\r\n    }\r\n\r\n    /*@devdoc\r\n     *  Acts upon commands posted to the audio worklet's message port.\r\n     *  @function AudioInputProcessor.onMessage\r\n     *  @param {MessageEvent} message - The message posted to the audio worklet, with <code>message.data</code> being a string\r\n     *      signifying the command. The following command is expected:\r\n     *      <p><code>\"clear\"</code>: Clear the audio sample buffer.</p>\r\n     */\r\n    onMessage = (message: MessageEvent) => {\r\n        if (message.data === \"clear\") {\r\n            this._resetInput();\r\n            this._resetOutput();\r\n        }\r\n    };\r\n\r\n    /*@devdoc\r\n     *  Called by the Web Audio pipeline to handle the next block of input audio samples, converting them to int16 samples at a\r\n     *  24000Hz sample rate and outputting them 240 frames at a time by posting a message on the AudioWorkletProcessor port.\r\n     *  @param {Float32Array[][]} inputList - Input PCM audio samples. An array of inputs, each of which is an array of\r\n     *      channels, each of which has 128 float32 samples in the range <code>-1.0</code> &ndash; <code>1.0</code>.\r\n     *  @param {Float32Array[][]} outputList - Output PCM audio samples. <em>Not used.</em>\r\n     *  @param {Record<string, Float32Array>} parameters - Processing parameters. <em>Not used.</em>\r\n     *  @returns {boolean} <code>true</code> to keep the processor node alive.\r\n     */\r\n    // eslint-disable-next-line\r\n    // @ts-ignore\r\n    process(inputList: Float32Array[][] /* , outputList: Float32Array[][], parameters: Record<string, Float32Array> */) {\r\n        if (!inputList || !inputList[0] || !inputList[0][0] || this._channelCount === 2 && !inputList[0][1]) {\r\n            return true;\r\n        }\r\n\r\n        this._processor(inputList[0]);\r\n\r\n        return true;\r\n    }\r\n\r\n    _resetOutput() {\r\n        this._output = new Int16Array(this._outputSize);\r\n        this._outputView = new DataView(this._output.buffer);\r\n        this._outputIndex = 0;\r\n    }\r\n\r\n    _resetInput() {\r\n        this._inputSampleCount = 0;\r\n        this._inputFraction = 0.0;\r\n        this._inputAccumulator = [0.0, 0.0];\r\n        // Do not reset this._lastInputValue.\r\n    }\r\n\r\n    _convert = (input: Array<Float32Array>) => {\r\n        // A straight conversion from float32 to int16 values, posting the output buffer when full.\r\n        const BYTES_PER_INT16_SAMPLE = 2;\r\n        const BYTES_PER_INT16_FRAME = this._channelCount * BYTES_PER_INT16_SAMPLE;\r\n\r\n        for (let i = 0, inputSize = (input[0] as Float32Array).length; i < inputSize; i++) {\r\n\r\n            const rawIndex = this._outputIndex * BYTES_PER_INT16_FRAME;\r\n            for (let channel = 0; channel < this._channelCount; channel++) {\r\n                const inputSample = (input[channel] as Float32Array)[i] as number;\r\n                const rawChannel = channel * BYTES_PER_INT16_SAMPLE;\r\n                this._outputView.setInt16(rawIndex + rawChannel, inputSample * this.FLOAT_TO_INT, this.LITTLE_ENDIAN);\r\n            }\r\n\r\n            this._outputIndex += 1;\r\n            if (this._outputIndex === this._outputSampleSize) {\r\n                this.port.postMessage(this._output.buffer, [this._output.buffer]);\r\n                this._resetOutput();\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    _downsample = (input: Array<Float32Array>) => {\r\n        // A simple low-pass filter that assigns proportions of each input sample to output samples, posting the output buffer\r\n        // when full. Values are resynchronized every second to avoid error accumulation.\r\n        const BYTES_PER_INT16_SAMPLE = 2;\r\n        const BYTES_PER_INT16_FRAME = this._channelCount * BYTES_PER_INT16_SAMPLE;\r\n\r\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\r\n\r\n        for (let i = 0, inputSize = (input[0] as Float32Array).length; i < inputSize; i++) {\r\n            this._inputSampleCount += 1;\r\n\r\n            if (this._inputFraction + this._downsampleRatio < 1.0 && this._inputSampleCount !== this._inputSampleRate) {\r\n                // End of input sample < end of output sample, provided that it's not the final sample in a second (avoid\r\n                // possible accumulated error condition).\r\n\r\n                for (let channel = 0; channel < this._channelCount; channel++) {\r\n                    // Add whole of input to input accumulator.\r\n                    this._inputAccumulator[channel] += (input[channel] as Float32Array)[i] as number;\r\n                    this._inputFraction += this._downsampleRatio;\r\n                }\r\n\r\n            } else {\r\n                // End of input sample >= end of output sample, or final sample of a second.\r\n\r\n                const rawIndex = this._outputIndex * BYTES_PER_INT16_FRAME;\r\n                for (let channel = 0; channel < this._channelCount; channel++) {\r\n                    // Add proportion of input to input accumulator.\r\n                    const proportion = (1 - this._inputFraction) / this._downsampleRatio;\r\n                    const value = (input[channel] as Float32Array)[i] as number;\r\n                    this._inputAccumulator[channel] += proportion * value;\r\n\r\n                    // Convert and write output.\r\n                    const rawChannel = channel * BYTES_PER_INT16_SAMPLE;\r\n                    this._outputView.setInt16(rawIndex + rawChannel,\r\n                        this._inputAccumulator[channel]! * this._downsampleRatio * this.FLOAT_TO_INT, this.LITTLE_ENDIAN);\r\n\r\n                    // Set input accumulator to remainder of input.\r\n                    const remainder = 1.0 - proportion;\r\n                    this._inputFraction = remainder * this._downsampleRatio;\r\n                    this._inputAccumulator[channel] = remainder * value;\r\n                }\r\n\r\n                this._outputIndex += 1;\r\n            }\r\n\r\n            // Post output if buffer full.\r\n            if (this._outputIndex === this._outputSampleSize) {\r\n                this.port.postMessage(this._output.buffer, [this._output.buffer]);\r\n                this._resetOutput();\r\n            }\r\n\r\n            // Reset input each second to avoid accumulated errors.\r\n            if (this._inputSampleCount === this._inputSampleRate) {\r\n                this._resetInput();\r\n            }\r\n\r\n            /* eslint-enable @typescript-eslint/no-non-null-assertion */\r\n        }\r\n    };\r\n\r\n    _upsample = (input: Array<Float32Array>) => {\r\n        // A simple linear interpolation resampler, posting the output buffer when full. Values are resynchronized every second\r\n        // to avoid error accumulation.\r\n        const BYTES_PER_INT16_SAMPLE = 2;\r\n        const BYTES_PER_INT16_FRAME = this._channelCount * BYTES_PER_INT16_SAMPLE;\r\n\r\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\r\n\r\n        const inputSize = (input[0] as Float32Array).length;\r\n        let inputIndex = 0;\r\n        let inputValues = [];\r\n        for (let channel = 0; channel < this._channelCount; channel++) {\r\n            inputValues.push((input[channel] as Float32Array)[0] as number);\r\n        }\r\n\r\n        // Process input into output.\r\n        while (inputIndex < inputSize) {\r\n\r\n            // Calculate output value = last-input-value + fraction * (this-input-value - last-input-value).\r\n            const rawIndex = this._outputIndex * BYTES_PER_INT16_FRAME;\r\n            for (let channel = 0; channel < this._channelCount; channel++) {\r\n                const rawChannel = channel * BYTES_PER_INT16_SAMPLE;\r\n                const lastValue = this._lastInputValues[channel]!;\r\n                const nextValue = inputValues[channel]!;\r\n                this._outputView.setInt16(rawIndex + rawChannel,\r\n                    lastValue + this._inputFraction * (nextValue - lastValue) * this.FLOAT_TO_INT, this.LITTLE_ENDIAN);\r\n            }\r\n            this._outputIndex += 1;\r\n\r\n            // Post output if buffer full.\r\n            if (this._outputIndex === this._outputSampleSize) {\r\n                this.port.postMessage(this._output.buffer, [this._output.buffer]);\r\n                this._resetOutput();\r\n            }\r\n\r\n            this._inputFraction += this._upsampleRatio;\r\n            if (this._inputFraction > 1.0) {\r\n\r\n                // Advance to the next pair of inputs.\r\n                this._lastInputValues = inputValues;\r\n                inputIndex += 1;\r\n                if (inputIndex < inputSize) {\r\n                    this._inputSampleCount += 1;\r\n                    inputValues = [];\r\n                    for (let channel = 0; channel < this._channelCount; channel++) {\r\n                        inputValues.push((input[channel] as Float32Array)[inputIndex] as number);\r\n                    }\r\n                }\r\n\r\n                this._inputFraction -= 1.0;\r\n            }\r\n\r\n            // Reset input each second to avoid accumulated errors.\r\n            if (this._inputSampleCount === this._inputSampleRate) {\r\n                this._resetInput();\r\n            }\r\n        }\r\n\r\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\r\n    };\r\n\r\n}\r\n\r\nregisterProcessor(\"vircadia-audio-input-processor\", AudioInputProcessor);\r\n"],"names":["AudioConstants","SAMPLE_RATE","STEREO","NETWORK_FRAME_SAMPLES_STEREO","NETWORK_FRAME_SAMPLES_PER_CHANNEL","NETWORK_FRAME_SECS","this","NETWORK_FRAME_MSECS","AUDIO_WORKLET_BLOCK_SIZE","AudioInputProcessor","AudioWorkletProcessor","FLOAT_TO_INT","LITTLE_ENDIAN","_channelCount","_output","_outputView","_outputSize","_outputSampleSize","_outputIndex","_inputSampleRate","_inputFraction","_inputSampleCount","_downsampleRatio","_inputAccumulator","_upsampleRatio","_lastInputValues","_processor","_haveReportedUpSampleError","constructor","options","super","channelCount","Math","min","sampleRate","_convert","_downsample","_upsample","Int16Array","DataView","buffer","port","onmessage","onMessage","message","data","_resetInput","_resetOutput","process","inputList","input","BYTES_PER_INT16_FRAME","i","inputSize","length","rawIndex","channel","inputSample","rawChannel","setInt16","postMessage","proportion","value","remainder","inputIndex","inputValues","push","lastValue","nextValue","registerProcessor"],"sourceRoot":""}