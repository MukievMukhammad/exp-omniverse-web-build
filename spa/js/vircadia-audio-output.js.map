{"version":3,"file":"vircadia-audio-output.js","mappings":"AA2BA,MAAMA,UAA6BC,sBAI/BC,aAA6B,GAEpBC,wBAA0B,IAC1BC,wBAA0B,IACnCC,YAAa,EACbC,qBAAsB,EAGtBC,YAAYC,GACRC,MAAMD,GAENE,KAAKC,KAAKC,UAAYF,KAAKG,SAC/B,CAYAA,UAAaC,IAET,MAAMC,EAAa,IAAIC,WAAWF,EAAQG,MAI1C,GAHAP,KAAKR,aAAagB,KAAKH,GAGnBL,KAAKR,aAAaiB,OAAST,KAAKP,wBAAyB,CAEzD,KAAOO,KAAKR,aAAaiB,OAAST,KAAKP,yBACnCO,KAAKR,aAAakB,QAEjBV,KAAKJ,sBACNe,QAAQC,IAAI,4CACZZ,KAAKJ,qBAAsB,E,EAK9BI,KAAKL,YAAcK,KAAKR,aAAaiB,QAAUT,KAAKN,0BAErDM,KAAKL,YAAa,GAItBK,KAAKC,KAAKY,YAAYb,KAAKR,aAAaiB,OAAO,EAenDK,QAAQC,EAA6BC,GAKjC,IAAIX,EAWJ,GAVIL,KAAKL,aACLU,EAAaL,KAAKR,aAAakB,QAC/BV,KAAKC,KAAKY,YAAYb,KAAKR,aAAaiB,aACrBQ,IAAfZ,IAEAL,KAAKL,YAAa,EAClBK,KAAKJ,qBAAsB,MAI9BoB,GAAeA,EAAW,IAAOA,EAAW,GAAG,IAAOA,EAAW,GAAG,IACrE,OAAO,EAGX,MAEME,EAAcC,KAAKC,IAAIJ,EAAW,GAAG,GAAGP,OAAQJ,EAAaA,EAAWI,OAAS,EADnD,KAG9BY,EAASL,EAAW,GAC1B,IAAK,IAAIM,EAAU,EAAGA,EALD,EAKyBA,IAAW,CACrD,MAAMC,EAAUF,EAAOC,GACvB,IAAK,IAAIE,EAAI,EAAGA,EAAIN,EAAaM,IAAK,CAClC,IAAIC,EAAS,EACTpB,IACAoB,EAASpB,EAAe,EAAJmB,EAAQF,GA5BnB,OA8BbC,EAAQC,GAAKC,C,EAIrB,OAAO,CACX,EAGJC,kBAAkB,kCAAmCpC","sources":["webpack://@vircadia/web-sdk/./src/domain/worklets/AudioOutputProcessor.ts"],"sourcesContent":["//\r\n//  AudioOutputProcessor.ts\r\n//\r\n//  Created by David Rowe on 14 Sep 2021.\r\n//  Copyright 2021 Vircadia contributors.\r\n//  Copyright 2021 DigiSomni LLC.\r\n//\r\n//  Distributed under the Apache License, Version 2.0.\r\n//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html\r\n//\r\n\r\n\r\n/*@devdoc\r\n *  The <code>AudioOutputProcessor</code> class implements a Web Audio\r\n *  {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletProcessor|AudioWorkletProcessor} that outputs SDK audio\r\n *  to a MediaStream. It is used as a node in a Web Audio graph in {@link AudioOutput}.\r\n *  <p>It runs on its own thread and uses a ring buffer to buffer an amount of data received to play in order to help maintain a\r\n *  smooth output stream.</p>\r\n *  <p>C++: <code>N/A</code></p>\r\n *  @class AudioOutputProcessor\r\n *  @param {AudioWorkletNodeOptions} options -\r\n *    {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletProcessor/AudioWorkletProcessor|AudioWorkletProcessor}\r\n *    options.\r\n *\r\n *  @property {MessagePort} port - Used to communicate between the AudioWorkletProcessor object and its internal code. See\r\n *    {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletNode/port|AudioWorkletNode.port}.\r\n */\r\nclass AudioOutputProcessor extends AudioWorkletProcessor {\r\n\r\n    // Buffer blocks of audio data so that they can be played back smoothly.\r\n    // FIXME: All these fields should be private (#s) but Firefox isn't handling transpiled code with them (Sep 2021).\r\n    _audioBuffer: Int16Array[] = [];\r\n    // MAX_AUDIO_BUFFER_LENGTH = AudioClient.#RECEIVED_AUDIO_STREAM_CAPACITY_BLOCKS\r\n    readonly MAX_AUDIO_BUFFER_LENGTH = 360;  // The maximum number of audio blocks to buffer\r\n    readonly MIN_AUDIO_BUFFER_LENGTH = 180;  // The minimum number of audio blocks to have before starting to play them.\r\n    _isPlaying = false;  // Is playing audio blocks from the buffer.\r\n    _haveLoggedOverflow = false;\r\n\r\n\r\n    constructor(options?: AudioWorkletNodeOptions) {\r\n        super(options);\r\n\r\n        this.port.onmessage = this.onMessage;\r\n    }\r\n\r\n\r\n    /*@devdoc\r\n     *  Takes incoming audio blocks posted to the audio worklet's message port and queues them in a ring buffer for playing.\r\n     *  If too many audio blocks are queued, some of the older ones are discarded.\r\n     *  If too few audio blocks are queued, playing is paused while a minimum number of audio blocks are accumulated.\r\n     *  The number of audio blocks buffered is posted on the message port.\r\n     *  @function AudioOutputProcessor.onMessage\r\n     *  @param {MessageEvent} message - The message posted to the audio worklet, with <code>message.data</code> being an\r\n     *      <code>Int16Array</code> of PCM audio samples, ready to play.\r\n     */\r\n    onMessage = (message: MessageEvent) => {\r\n        // Buffer the new block of audio samples.\r\n        const audioBlock = new Int16Array(message.data);\r\n        this._audioBuffer.push(audioBlock);\r\n\r\n        // If we've surpassed the maximum buffer size, skip some older audio blocks.\r\n        if (this._audioBuffer.length > this.MAX_AUDIO_BUFFER_LENGTH) {\r\n            // The incoming audio stream should be <= the rate of consumption so only skip the minimum number of blocks.\r\n            while (this._audioBuffer.length > this.MAX_AUDIO_BUFFER_LENGTH) {\r\n                this._audioBuffer.shift();\r\n            }\r\n            if (!this._haveLoggedOverflow) {\r\n                console.log(\"AudioOutputProcessor: Buffer overflowed.\");\r\n                this._haveLoggedOverflow = true;\r\n            }\r\n        }\r\n\r\n        // Start playing if not playing and we now have enough audio blocks.\r\n        if (!this._isPlaying && this._audioBuffer.length >= this.MIN_AUDIO_BUFFER_LENGTH) {\r\n            // console.log(\"AudioOutputProcessor: Start playing.\");\r\n            this._isPlaying = true;\r\n        }\r\n\r\n        // Report the number of audio blocks buffered.\r\n        this.port.postMessage(this._audioBuffer.length);\r\n    };\r\n\r\n\r\n    /*@devdoc\r\n     *  Called by the Web Audio pipeline to provide the next block of audio samples to play. The next audio block from the ring\r\n     *  buffer is played if one is available and playing is not paused, otherwise a block of silence is played. The Int32 values\r\n     *  from the ring buffer are converted to Float32 values.\r\n     *  @param {Float32Array[][]} inputList - Input PCM audio samples. <em>Not used.</em>\r\n     *  @param {Float32Array[][]} outputList - Output PCM audio samples.\r\n     *  @param {Record<string, Float32Array>} parameters - Processing parameters. <em>Not used.</em>\r\n     *  @returns {boolean} <code>true</code> to keep the processor node alive.\r\n     */\r\n    // eslint-disable-next-line\r\n    // @ts-ignore\r\n    process(inputList: Float32Array[][], outputList: Float32Array[][] /* , parameters: Record<string, Float32Array> */) {\r\n\r\n        const FLOAT_TO_INT = 32767;\r\n\r\n        // Grab the next block of audio to play.\r\n        let audioBlock: Int16Array | undefined = undefined;\r\n        if (this._isPlaying) {\r\n            audioBlock = this._audioBuffer.shift();\r\n            this.port.postMessage(this._audioBuffer.length);\r\n            if (audioBlock === undefined) {\r\n                // console.log(\"AudioOutputProcessor: Stop playing.\");\r\n                this._isPlaying = false;\r\n                this._haveLoggedOverflow = false;\r\n            }\r\n        }\r\n\r\n        if (!outputList || !outputList[0] || !outputList[0][0] || !outputList[0][1]) {\r\n            return true;\r\n        }\r\n\r\n        const channelCount = 2;\r\n        const EXPECTED_AUDIO_BLOCK_FRAMES = 128;\r\n        const sampleCount = Math.min(outputList[0][0].length, audioBlock ? audioBlock.length / 2 : EXPECTED_AUDIO_BLOCK_FRAMES);\r\n\r\n        const output = outputList[0];\r\n        for (let channel = 0; channel < channelCount; channel++) {\r\n            const samples = output[channel] as Float32Array;\r\n            for (let i = 0; i < sampleCount; i++) {\r\n                let sample = 0;\r\n                if (audioBlock) {\r\n                    sample = audioBlock[i * 2 + channel] as number / FLOAT_TO_INT;\r\n                }\r\n                samples[i] = sample;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nregisterProcessor(\"vircadia-audio-output-processor\", AudioOutputProcessor);\r\n"],"names":["AudioOutputProcessor","AudioWorkletProcessor","_audioBuffer","MAX_AUDIO_BUFFER_LENGTH","MIN_AUDIO_BUFFER_LENGTH","_isPlaying","_haveLoggedOverflow","constructor","options","super","this","port","onmessage","onMessage","message","audioBlock","Int16Array","data","push","length","shift","console","log","postMessage","process","inputList","outputList","undefined","sampleCount","Math","min","output","channel","samples","i","sample","registerProcessor"],"sourceRoot":""}